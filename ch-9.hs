--1
choices :: [a] -> [[a]]
choices xs = [zs | ys <- subs xs, zs <- perms ys]

--2
removeone :: a -> [a] -> [a]
removeone x []    = []
removeone x (y:ys)
 | x == y         = ys
 | otherwise      = y : removeone x ys

isChoice : Eq a => [a] -> [a] -> Bool
isChoice [] _ = True
isChoice (x:xs) [] = False
isChoice (x:xs) ys = elem x ys && isChoice xs (removeone x ys)

--3
exp won't terminate, which means that solutions won't terminate either.

--5
valid :: Op -> Int -> Int -> Bool
valid Add _ _ = True
valid Sub x y = True
valid Mul _ _ = True
valid Div x y = x 'mod' y == 0

--6a (Only modified code shown)
data  Op = Add | Sub | Mul | Div | Expo

instance Show Op where
  show Add = "+"
  show Sub = "-"
  show Mul = "*"
  show Div = "/"
  show Expo = "^"

instance Show Expr where
  show (Val n) = show n
  show (App o l r) = brak l ++ show o ++ brak r
                     where
                       brak (Val n) = show n
                       brak e       = "(" ++ show e ++ ")"

valid :: Op -> Int -> Int -> Bool
valid _ _ = x <= y
valid Sub x y = x > y
valid Mul _ _ =  x /= 1 && y /= 1 && x <= y
valid Div x y = y /= 1 && x 'mod' y == 0
valid Expo x y = y >= 0

valid :: Op -> Int -> Int -> Int
apply Add x y = x + y
apply Sub x y = x - y
apply Mul x y = x * y
apply Div x y = x 'div' y
apply Expo x y = x ^ y

--6b (Only modified code shown)
solutions :: [Int] -> Int -> [Expr]
solutions ns n = [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]

--Takes list of exp generated by solutions, the two solutions inputs, and a distance tracker.
--If 1st param is empty list, tries to generate solutions on ints 1 less and 1 more than target. If unsuccessful, distance is increased and the whole process is reattempted.
--If 1st param is nonempty, returns it.
solutions' :: [Expr] -> [Int] -> Int -> Int -> [Expr]
solutions' [] m n d = solutions' ((solutions m (n-1)) ++ (solutions m (n+1))) m n (d+1)
solutions' x _ _ _ = x

--6c (Only modified code shown)

--quicksorts a list of expressions
sortsolutions :: [Expr] -> [Expr]
sortsolutions [] = []
sortsolutions [e] = [e]
sortsolutions (x:xs) = (sortsolutions shorter) ++ [x] ++ (sortsolutions longer)
                       where
                         shorter = [a | a <- xs, length (values a) <= length (values x)]
                         longer = [b | b <- xs, length (values b) > length (values x)]
